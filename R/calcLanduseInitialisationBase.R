#' @title calcLanduseInitialisationBase
#' @description Calculates the cellular MAgPIE landuse initialisation area. Data from FAO on forestry is used
#' to split the secondary forest pool of the LU2v2 dataset into forestry and secd_forest. This function
#' returns the data set in a basic configuration. Use \code{\link{calcLanduseInitialisation}} for
#' more settings.
#'
#' @param cells "magpiecell" for 59199 cells or "lpjcell" for 67420 cells
#' @param selectyears Years to be computed
#' @return Cellular landuse initialisation in its base configuration
#' @author Jan Philipp Dietrich, Benjamin Leon Bodirsky, Kristine Karstens, Felcitas Beier, Patrick v. Jeetze
#' @examples
#' \dontrun{
#' calcOutput("LanduseInitialisationBase", aggregate = FALSE)
#' }
calcLanduseInitialisationBase <- function(cells = "lpjcell", selectyears = "past_til2020") {

  selectyears <- sort(findset(selectyears, noset = "original"))
  selectyears <- as.integer(gsub("y", "", selectyears))


  .luIni <- function(luh, forestArea) {
    .shr <- function(x) {
      x <- x + 10^-10
      return(x / dimSums(x, dim = 3))
    }

    .expand <- function(x, target) {
      map <- data.frame(from = getItems(target, dim = "iso", full = TRUE),
                        to = getItems(target, dim = 1))
      return(toolAggregate(x[getItems(target, dim = "iso"), , ], map, from = "from", to = "to"))
    }
    map <- data.frame(luh = c("c3ann", "c4ann", "c3per", "c4per", "c3nfx", "pastr", "range",
                              "primf",      "secdf",      "secdf",    "urban", "primn", "secdn"),
                      lu  = c("crop",  "crop",  "crop",  "crop",  "crop",  "past",  "range",
                              "primforest", "secdforest", "forestry", "urban", "other", "other"))
    lu <- toolAggregate(luh, map, dim = 3)
    # Attention: mapping maps secdf on both: secdforest and forestry (both contain after aggregation the full secondary
    #           forest area)! Next step will calculate proper shares and multiply it to compute correct areas
    secdf <- c("secdforest", "forestry")
    forestShares <- .expand(x = .shr(forestArea[, , secdf]), target = lu)
    lu[, , secdf] <- forestShares * lu[, , secdf]
    return(lu)
  }

  .natureTarget <- function(lu, forestArea) {
    # compute target for primforest, secdforest and other (aggregate of primother and secdother)
    forests <- c("primforest", "secdforest", "forestry")
    nature  <- c(forests, "other")

    # Correct for overflow effects (forestArea greater than forest and other land available in luInit)
    overflow <- forestArea[, , "forest"] - dimSums(lu[, , nature], dim = 3)
    overflow[overflow < 0] <- 0
    if (any((of <- dimSums(overflow, dim = 1)) > 0)) {
      vcat(verbosity = 2, paste("Mismatch of FAO forest exceed LUH forest + other land by:",
                                paste0(paste(getYears(of), round(of, 0), "Mha"), collapse = ", "),
                                "- FAO forest data will be cut."))
      # corrected forest areas <- weight of forest subcategories * corrected total forest area
      corr <- setNames((forestArea[, , "forest"] + 10e-10 - overflow) / (forestArea[, , "forest"] + 10e-10), NULL)
      forestArea <- corr * forestArea
    }

    # compute other land area (diff between total natural land and forest area)
    otherArea <- setNames(dimSums(lu[, , nature], dim = 3) - forestArea[, , "forest"], "other")
    if (any(otherArea < -10e-6)) {
      warning("Other land area is partly negative. This should not be the case! values will be corrected to 0.")
    }
    # due to rounding there are always some very small values below 0 which is why it is always corrected to 0, but
    # a warning is only triggered for values smaller than 10e-6
    otherArea[otherArea < 0] <- 0

    return(mbind(forestArea[, , forests], otherArea))
  }

  # cellular landuse area
  luh <- calcOutput("LUH3", landuseTypes = "LUH3", irrigation = FALSE, cellular = TRUE,
                    yrs = selectyears, aggregate = FALSE)
  # country-level forest area
  forestArea <- calcOutput("ForestArea", selectyears = selectyears, aggregate = FALSE)
  # rename categories and split secondary forest into secondary forest and forestry
  # based on forestArea information (area sizes kept as reported by luh)
  lu <- .luIni(luh, forestArea)

  luCountry <- toolCountryFill(dimSums(lu, dim = c("x", "y")),
                               fill = 0, verbosity = 2)
  natTarget <- .natureTarget(luCountry, forestArea)

  vegC  <- calcOutput("LPJmL_new", subtype = "vegc", stage = "smoothed",
                      version = "LPJmL4_for_MAgPIE_44ac93de", climatetype = "GSWP3-W5E5:historical",
                      aggregate = FALSE)

  vegC <- toolFillYears(vegC, getYears(luh))

  cyears <- intersect(getYears(vegC, as.integer = TRUE), selectyears)
  vegC <- vegC[, cyears, ]

  lu2 <- toolForestRelocate(lu = lu, luCountry = luCountry, natTarget = natTarget, vegC = vegC)

  .splitOther <- function(lu, luh) {
    # split other land in primary and secondary other land
    # try to adjust only secondary other land and only touch primary other land
    # if total other land is smaller than primary other land
    other <- setNames(luh[, , c("primn", "secdn")], c("primother", "secdother"))
    secdother <- setNames(lu[, , "other"] - other[, , "primother"], NULL)
    # handle cases in which the above calculation became negative
    if (any(secdother < 0)) {
      remove  <- -secdother
      remove[remove < 0] <- 0
      secdother[secdother < 0] <- 0
      other[, , "primother"] <- other[, , "primother"] - remove
    }
    other[, , "secdother"] <- secdother
    if (max(abs(dimSums(other, dim = 3) - lu[, , "other"])) > 10e-6) {
      warning("splitted other land does not sum up to total other land!")
    }
    return(mbind(lu[, , "other", invert = TRUE], other))
  }

  out <- .splitOther(lu2, luh)

  if (cells == "magpiecell") {
    out <- toolCoord2Isocell(out, cells = cells)
  }

  if (any(out < 0)) {
    if (min(out) < -10e-6) {
      warning("Negative land values detected in LanduseInitialisationBase and replaced by 0.")
    }
    out[out < 0] <- 0
  }

  return(list(x = out,
              weight = NULL,
              unit = "Mha",
              min = 0,
              max = 14900, ### global land area
              description = "Land use initialisation data for different land pools",
              isocountries = FALSE))
}
